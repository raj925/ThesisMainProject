---
title: "VRMain"
output:
  html_document: 
    df_print: paged
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 3
    number_sections: false
    theme: lumen
  pdf_document: default
date: "2023-09-01"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Packages + Retrieve Data

```{r, warning=FALSE, message=FALSE}
source("../packageLoad.R")
require(NLP)

# Function used to plot box plots within violins
# Plots means +/-1 standard deviation
data_summary <- function(x) {
  m <- mean(x)
  ymin <- m-sd(x)
  ymax <- m+sd(x)
  return(c(y=m,ymin=ymin,ymax=ymax))
}

```

```{r, echo=FALSE}

# Colour coding for figures
confidenceColour <- "#03c200"
difficultyColour <- "#bf00c2"
infoSeekingColour <- "#ca0600"
differentialColour <- "skyblue"
likelihoodColour <- "orange"
accuracyColour <- "black"
resolutionColour <- "yellow"
```

```{r message=FALSE, warning=FALSE}

vrData <- data.frame()
sessionsData <- data.frame()
actionsData <- data.frame()

# Each round is a session where each participant did one of the scenarios
# So rounds 1 and 2 are the same set of participants doing one of the two scenarios.
# And order is fixed so in sessions 1,3,5 they do Asthma and DKA
# In sessions 2,4,6 they did Pneumonia and Seizure
numOfRounds <- length(list.files(path = "./Data/Questionnaires"))

# These are scenarios in the order they were performed across the two sessions
scens <- c("Asthma","DKA","Pneumonia","Seizure")

for (n in 1:numOfRounds)
{
  # Loading and collating data files
  vrFile <- paste("./Data/Questionnaires/VRData",n,".csv",sep = "")
  vrFile <- read.csv(vrFile,header=TRUE,sep=",")
  vrFile <- as.data.frame(vrFile)
  vrFile$round <- n
  vrData <- rbind(vrData,vrFile)
  
  # Load OMS actions and sessions data
  actionsFile <- paste("./Data/Actions/actionsData",n,".csv",sep = "")
  actionsFile <- read.csv(actionsFile,header=TRUE,sep=",")
  actionsFile <- as.data.frame(actionsFile)
  actionsFile$round <- n
  actionsData <- rbind(actionsData,actionsFile)
  
  sessionsFile <- paste("./Data/Sessions/sessionsData",n,".csv",sep = "")
  sessionsFile <- read.csv(sessionsFile,header=TRUE,sep=",")
  sessionsFile <- as.data.frame(sessionsFile)
  sessionsFile$round <- n
  sessionsData <- rbind(sessionsData,sessionsFile)
  
}

ids <- vrData$ParticipantID
# Create a frequency table
freq_table <- table(ids)
# Identify elements with more than one occurrence
# This gives us participant IDs who performed two scenarios
# As some only performed one and did not attend the other session.
repeatIDs <- names(freq_table[freq_table > 1])

actioncategories <- read.csv("./Data/Actions/actionCategories.csv",header=TRUE,sep=",")

# OMS ID is the ID used to get the OMS data.
# OMS IDs and their accounts were reused by each set of participants.
vrData$OMSID <- as.integer(vrData$OMSID)

sessionsData$NAME <- as.integer(str_remove(sessionsData$NAME, "Paeds Account "))
actionsData$NAME <- as.integer(str_remove(actionsData$NAME, "Paeds Account "))

colnames(sessionsData)[colnames(sessionsData) == "NAME"] ="OMSID"
colnames(actionsData)[colnames(actionsData) == "NAME"] ="OMSID"

# Merge questionnaire data and OMS session data.
vrData <- merge(vrData, sessionsData, by = c("OMSID", "round"))

severitiesT1 <- c()
severitiesT2 <- c()

confidenceT1 <- c()
confidenceT2 <- c()

likelihoodsT1 <- c()
likelihoodsT2 <- c()

for (x in 1:nrow(vrData))
{
  # Participants are split into two groups where each group does a particular
  # pair of scenarios in a fixed order:
  # AS - Asthma in session one, Seizure in session two
  # DP - DKA in session one, Pneumonia in session two
  ifelse(vrData$Scenario[x]=="Asthma"|vrData$Scenario[x]=="Seizure",
         vrData$scenGroup[x]<-"AS",
         vrData$scenGroup[x]<-"DP")
  # Asthma and DKA are always done first in session one.
  # So check for order effects.
  ifelse(vrData$Scenario[x]=="Asthma"|vrData$Scenario[x]=="DKA",
         vrData$scenNum[x]<-1,
         vrData$scenNum[x]<-2)
  # Is this the 1st, 2nd, 3rd or 4th scenario?
  vrData$orderNum[x] <- match(vrData$Scenario[x],scens)
  
  # Diagnoses reported as a comma seperated list so needs to be split by commas
  # to create an array in R.
  diagnoses1 <- str_split(vrData$t1Diagnoses[[x]],",")[[1]]
  diagnoses2 <- str_split(vrData$t2Diagnoses[[x]],",")[[1]]
  vrData$t1numOfDiagnoses[x] <- length(diagnoses1)
  vrData$t2numOfDiagnoses[x] <- length(diagnoses2)
  
  # Similar for the likelihoods for each diagnosis.
  liks1 <- as.integer(str_split(vrData$t1Likelihoods[[x]],",")[[1]])
  liks2 <- as.integer(str_split(vrData$t2Likelihoods[[x]],",")[[1]])
  vrData$t1HighestLikelihood[x] <- max(liks1)
  vrData$t2HighestLikelihood[x] <- max(liks2)

  # Calculate how the key variables severity, confidence and the number of 
  # diagnoses changes between timepoint 1 and timepoint 2.
  vrData$severityChange[x] <- as.integer(vrData$t2Severity[[x]]) - as.integer(vrData$t1Severity[[x]])
  vrData$confidenceChange[x] <- as.integer(vrData$t2Confidence[[x]]) - as.integer(vrData$t1Confidence[[x]])
  vrData$t1numOfDiagnosesChange[x] <- length(diagnoses2) - length(diagnoses1)
  
  # Combine measure of how the overall diagnosis has changed. 
  vrData$diagnosticChange[x] <- abs(vrData$severityChange[x]) + abs(vrData$confidenceChange[x]) + abs(vrData$t1numOfDiagnosesChange[x])
  
  # Get arrays of all severities, confidence ratings and likelihood ratings
  # in each timepoint so can plot the distributions later on.
  severitiesT1 <- c(severitiesT1, as.integer(vrData$t1Severity[[x]]))
  severitiesT2 <- c(severitiesT2, as.integer(vrData$t2Severity[[x]]))
  confidenceT1 <- c(confidenceT1, as.integer(vrData$t1Confidence[[x]]))
  confidenceT2 <- c(confidenceT2, as.integer(vrData$t2Confidence[[x]]))
  likelihoodsT1 <- c(likelihoodsT1,liks1)
  likelihoodsT2 <- c(likelihoodsT2,liks2)
  
}

# Imperfect measure of calibration by comparing OMS Score relative to confidence
vrData$calibrationByDiff <- (vrData$OMSScore/vrData$t2Confidence)/10

# Get set of actions categorised under History, Exams or Testing
# From external file actioncategories
historyActions <- actioncategories$History
historyActions <- historyActions[which(historyActions != "")]

examActions <- actioncategories$Examination
examActions <- examActions[which(examActions != "")]

TestingActions <- actioncategories$Testing
TestingActions <- TestingActions[which(TestingActions != "")]

# All actions considered here are combination of these three
actionsMasterList <- c(historyActions, examActions, TestingActions)
actionsMasterList <- actionsMasterList[nzchar(actionsMasterList)]

# PEWs actions categorised so PEWs score generated by the participant
# can be calculated here. 
pewsActions <- actioncategories$PEWS
pewsActions <- pewsActions[which(pewsActions != "")]

# Scoring chart for PEWs score.
pewsTable <- read.csv("./Data/Actions/pewsActionsTable.csv",header=FALSE,sep=",")
colnames(pewsTable) <- c("1","0","1")


#################
# Attach information seeking data recorded in OMSs
for (n in 1:nrow(vrData))
{
  
  pptActions <- actionsData[actionsData$OMSID == vrData$OMSID[n] & actionsData$SCENARIO == vrData$SCENARIO[n] & actionsData$round == vrData$round[n],]
  # Get actions (clicks) for this participant for this scenario
  # Actions for all scenarios/participants are stored together in actionsData
  actions <- pptActions$ACTION.TITLE
  
  times <- pptActions$ACTION.TIMESTAMP..SECS.AFTER.START.
  
  
  # usedHistoryActions <- historyActions[historyActions %in% actionsData[actionsData$SCENARIO == vrData$SCENARIO[n],]$ACTION.TITLE]
  
  # Tricky thing here is to get the last thing clicked on for the PEWs chart
  pewsResps <- unique(actions[which(actions %in% pewsActions)])
  pewsVal <- 0
  
  sbarActions <- actioncategories$SBAR
  sbarStart <- unique(actions[which(actions %in% sbarActions)])
  sbarStart <- ifelse(length(sbarStart)<1,9999,min(pptActions[pptActions$ACTION.TITLE %in% sbarActions,]$ACTION.TIMESTAMP..SECS.AFTER.START.))
  
  helpActions <- actioncategories$Help
  helpStart <- unique(actions[which(actions %in% helpActions)])
  helpStart <- ifelse(length(sbarStart)<1,9999,min(pptActions[pptActions$ACTION.TITLE %in% helpActions,]$ACTION.TIMESTAMP..SECS.AFTER.START.))
  
  vrData$sbarStart[n] <- sbarStart
  vrData$helpStart[n] <- helpStart
  vrData$totalHelpStart[n] <- min(c(sbarStart,helpStart))
  
  for (row in 1:nrow(pewsTable))
  {
    pew <- pewsTable[row,] # Chart with the PEWs scoring criteria
    pewIdxs <- which(pewsResps %in% pew) # All PEWs clicks
    pewAns <- pewsResps[pewIdxs[which.max(pewIdxs)]] # Get the latest PEWs click
    pewsVal <- sum(c(pewsVal,as.numeric(colnames(pewsTable)[which(pew %in% pewAns)])))
  }
  vrData$pewsScore[n] <- pewsVal

  # How many clicks do participants make?
  vrData$totalActions[n] <- length(actions)
  vrData$uniqueActions[n] <- length(unique(actions)) 

  actionsVector <- c()
  actTimesVector <- c()
    
  # Generate a binary vector where each click is recorded
  # So for each action in the list of all actions,
  # which actions are clicked on in this scenario? 
  # Clicked on / sought = 1, not clicked on / sought = 0
  for (a in 1:length(actionsMasterList))
  {
    if (actionsMasterList[a] %in% actions)
    {
      actionsVector <- c(actionsVector,1)
      idx <- match(actionsMasterList[a],actions)
      actTimesVector <- c(actTimesVector,times[idx])
    } else {
      actionsVector <- c(actionsVector,0)
      actTimesVector <- c(actTimesVector,0)
    }
  } 
  
  # Number of actions belonging to History, Exams or Testing
  vrData$filteredActions[n] <- sum(actionsVector) 
  
  # Store actions vector as a string to retrieve later. 
  vrData$actionVector[n] <- as.String(actionsVector)
  vrData$actTimesVector[n] <- as.String(actTimesVector)

  # Same process for History, Exams and Testing information/actions separately.
  historyActionsVector <- c()
  examActionsVector <- c()
  testingActionsVector <- c()
  
  for (a in 1:length(historyActions))
  {
    if (historyActions[a] %in% actions)
    {
      historyActionsVector <- c(historyActionsVector,1)
    } else {
      historyActionsVector <- c(historyActionsVector,0)
    }
  }
  for (a in 1:length(examActions))
  {
    if (examActions[a] %in% actions)
    {
      examActionsVector <- c(examActionsVector,1)
    } else {
      examActionsVector <- c(examActionsVector,0)
    }
    } 
  for (a in 1:length(TestingActions))
  {
    if (TestingActions[a] %in% actions)
    {
      testingActionsVector <- c(testingActionsVector,1)
    } else {
      testingActionsVector <- c(testingActionsVector,0)
    }
  }
  vrData$historyActionsVector[n] <- as.String(historyActionsVector)
  vrData$examsActionsVector[n] <- as.String(examActionsVector)
  vrData$testingActionsVector[n] <- as.String(testingActionsVector)
  
  vrData$numOfHistoryActions[n] <- sum(historyActionsVector)
  vrData$numOfExamActions[n] <- sum(examActionsVector)
  vrData$numOfTestingActions[n] <- sum(testingActionsVector)
  
  vrData$numOfActionsAfterHistory[n] <- vrData$numOfExamActions[n] + vrData$numOfTestingActions[n] 
  
  vrData$numOfHistoryActionsBeforePause[n] <- sum(unique(actions)[times<300] %in% historyActions)
  vrData$percentageHistory[n] <- vrData$numOfHistoryActionsBeforePause[n]/vrData$numOfHistoryActions[n]
  
    vrData$numOfTestingActionsAfterPause[n] <- sum(unique(actions)[times>300] %in% TestingActions)
  vrData$percentageTesting[n] <- vrData$numOfTestingActionsAfterPause[n]/vrData$numOfTestingActions[n]
  
  vrData$historyVectorBeforePause[n] <- as.String(historyActions[historyActions %in% actions[times<300]])
  vrData$numOfActionsBeforePause[n] <- length(actions[times<300])
  vrData$numOfActionsAfterPause[n] <- length(actions[times>=300])
}

# If diagnoses are less than 4, they are considered a 'low' number
# This roughly splits observations into equally sized groups
vrData$numOfDiagnosesLabel <- ifelse(vrData$t1numOfDiagnoses<4,"low","high")
vrData$initialConfidenceLabel <- ifelse(vrData$t1Confidence<7,"low","high")


```

## Get information seeking matrix

```{r, warning=FALSE, message=FALSE}

infoSeekingMatrixVR <- data.frame(matrix(nrow = nrow(vrData), ncol = length(actionsMasterList)))

# Add to matrix from vectors stored as strings in vrData so we get a binary matrix.
for (n in 1:nrow(vrData))
{
  infoSeekingMatrixVR[n,] <- str_split(vrData$actionVector[n],"\n")[[1]]
}

infoSeekingMatrixVR <- apply(infoSeekingMatrixVR, 2, as.numeric)

infoSeekingMatrixVR <- as.data.frame(infoSeekingMatrixVR)
colnames(infoSeekingMatrixVR) <- actionsMasterList

# Use colSums to calculate the sum of each column
sumVals <- colSums(infoSeekingMatrixVR)

# Use the column sums to filter columns with at least one 1
filtered_data <- infoSeekingMatrixVR[, sumVals > 0]

# Get pairwise distances/dissimilarity
distancesVR <- infoSeekingMatrixVR %>% proxy::dist(method = "Hamman") %>% as.matrix()

infoSeekingMatrixVR$scenario <- vrData$Scenario
infoSeekingMatrixVR$OMSScore <- vrData$OMSScore
infoSeekingMatrixVR$t1Confidence <- vrData$t1Confidence
infoSeekingMatrixVR$t1DiagnosisScore <- vrData$t1DiagnosisScore

```

```{r, warning=FALSE, message=FALSE}

# Derive information values

valueDf <- data.frame(matrix(nrow=length(actionsMasterList),ncol=4))
rownames(valueDf) <- actionsMasterList
colnames(valueDf) <- scens


for (x in 1:nrow(valueDf))
{
  for (y in 1:ncol(valueDf))
  {
    act <- actionsMasterList[x]
    sce <- scens[y]
    
    scenActs <- infoSeekingMatrixVR[infoSeekingMatrixVR$scenario==sce,]
    
    soughtScens <- scenActs[scenActs[[act]]==1,]$OMSScore
    notSoughtScens <- scenActs[scenActs[[act]]==0,]$OMSScore 
    
    #soughtScens <- scenActs[scenActs[[act]]==1,]$t1DiagnosisScore
    #notSoughtScens <- scenActs[scenActs[[act]]==0,]$t1DiagnosisScore 
    
    if (length(soughtScens)<1 | length(notSoughtScens)<1)
    {
      valueDf[x,y] <- 0
    } else {
          valueDf[x,y] <- mean(soughtScens,na.rm=T) - mean(notSoughtScens,na.rm=T)
    }
  }
}

for (x in 1:nrow(vrData))
{
  vector <- infoSeekingMatrixVR[x,]
  vector <- vector[1:(length(vector)-2)] 
  
  sce <- vrData$Scenario[x]
  sceVals <- valueDf[[sce]]
  
  soughtVals <- vector[1:82] * sceVals
  
  #vrData$infoVal[x] <- mean(soughtVals[soughtVals!=0],na.rm=T)
  vrData$infoVal[x] <- sum(soughtVals,na.rm=T)
  
  historyVals <- soughtVals[1:length(historyActions)]
  #vrData$infoValHistory[x] <- mean(historyVals[historyVals!=0],na.rm = T)
  vrData$infoValHistory[x] <- sum(historyVals,na.rm = T)
  
  pptTimes <- str_split(vrData$actTimesVector[n],"\n")[[1]]
  pptTimes <- as.numeric(pptTimes)
  pptHistTimes <- pptTimes[1:length(historyActions)]
  vrData$infoValHistoryBeforePause[x] <- sum(historyVals[pptHistTimes<300&pptHistTimes>1],na.rm = T)
  
  vrData$infoValBeforePause[x] <- sum(soughtVals[pptTimes<300&pptTimes>1],na.rm = T)
  vrData$infoValAfterPause[x] <- sum(soughtVals[pptTimes>=300&pptTimes>1],na.rm = T)
  
  afterHistoryVals <- soughtVals[(length(historyActions)+1):length(soughtVals)]
  #vrData$infoValAfterHistory[x] <- mean(afterHistoryVals[afterHistoryVals!=0],na.rm = T)
  vrData$infoValAfterHistory[x] <- sum(afterHistoryVals,na.rm = T)
  
  
}


```

```{r, warning=FALSE, message=FALSE}
# Get data where participants have completed two scenarios

vrCompleteData <- vrData[vrData$ParticipantID %in% repeatIDs,]
vrCompleteData <- vrCompleteData[!is.na(vrCompleteData$t2Confidence),]
ids <- vrCompleteData$ParticipantID
# Create a frequency table
freq_table <- table(ids)
# Identify elements with more than one occurrence
repeatIDs <- names(freq_table[freq_table > 1])
vrCompleteData <-  vrCompleteData[vrCompleteData$ParticipantID %in% repeatIDs,]
nFullPpts <- nrow(vrCompleteData)/2

vrDataNoNAs <- vrData[!is.na(vrData$diagnosticChange),]


```

Analyses:
- Distribution of confidence and severity ratings
- Confidence with and without completing investigations t-test
- Change of confidence against score correlation
- Difference in score and severity/confidence change by scenario

## Distributions of Confidence, Severity and Likelihoods

```{r, warning=FALSE, message=FALSE}


title <- paste("Confidence Ratings", sep="")

dat <- data.frame(c(confidenceT1,confidenceT2),c(rep("T1",length(confidenceT1)),rep("T2",length(confidenceT2))))
colnames(dat) <- c("confidence","timepoint")

# Interleaved histograms
ggplot(dat, aes(x=confidence, color=timepoint, fill=timepoint )) +
    geom_histogram(binwidth=1, color="#e9ecef", alpha=0.7, position="dodge") +
    scale_fill_manual(values=c("#DDCC77", "#88CCEE")) +
    scale_x_continuous(breaks=seq(1,10,1)) +
    theme_classic() +
    ggtitle(title)

title <- paste("Severity Ratings", sep="")

dat <- data.frame(c(severitiesT1,severitiesT2),c(rep("T1",length(severitiesT1)),rep("T2",length(severitiesT2))))
colnames(dat) <- c("severity","timepoint")

# Interleaved histograms
ggplot(dat, aes(x=severity, color=timepoint, fill=timepoint )) +
    geom_histogram(binwidth=1, color="#e9ecef", alpha=0.7, position="dodge") +
    scale_fill_manual(values=c("#44AA99", "#CC6677")) +
    scale_y_continuous(breaks=seq(0,11,1)) +
    scale_x_continuous(breaks=seq(2,10,1)) +
    theme_classic() +
    ggtitle(title)


title <- paste("Likelihood Ratings", sep="")

dat <- data.frame(c(likelihoodsT1,likelihoodsT2),c(rep("T1",length(likelihoodsT1)),rep("T2",length(likelihoodsT2))))
colnames(dat) <- c("likelihood","timepoint")

# Interleaved histograms
ggplot(dat, aes(x=likelihood, color=timepoint, fill=timepoint )) +
    geom_histogram(binwidth=1, color="#e9ecef", alpha=0.7, position="dodge") +
    scale_fill_manual(values=c("#999933", "#882255")) +
    theme_classic() +
    ggtitle(title)



```

## Initial Correlations

```{r, warning=FALSE, message=FALSE}


confScore <- ggplot(data = vrCompleteData, aes(x=t2Confidence, y=OMSScore)) +
  geom_point() +
  geom_smooth(method=lm , color="purple", fill="#69b3a2", se=TRUE) +
  theme_classic()

print(confScore + 
        ggtitle("Confidence Against OMS Score")
      + labs(y="OMS Score", x = "Confidence (Time 2)"))

cor.test(vrCompleteData$t2Confidence,vrCompleteData$OMSScore,method="pearson")


confScore <- ggplot(data = vrCompleteData, aes(x=t2Confidence, y=severityChange)) +
  geom_point() +
  geom_smooth(method=lm , color="red", fill="#69b3a2", se=TRUE) +
  theme_classic()

print(confScore + 
        ggtitle("Confidence Against Change in Severity")
      + labs(y="Difference in Severity", x = "Confidence (Time 2)"))

cor.test(vrCompleteData$severityChange,vrCompleteData$OMSScore,method="pearson")


seniorSev <- ggplot(data = vrCompleteData, aes(x=t2Severity, y=t2SeniorReview)) +
  geom_point() +
  geom_smooth(method=lm , color="orange", fill="#69b3a2", se=TRUE) +
  theme_classic()

print(seniorSev + 
        ggtitle("Severity against Willingness to Leave Patient")
      + labs(y="Leave Patient Prior to Senior Review", x = "Severity (Time 2)"))

cor.test(vrCompleteData$t2Severity,vrCompleteData$t2SeniorReview,method="pearson")

```

## Confidence by Timepoint

```{r, warning=FALSE, message=FALSE}

se <- c(sd(vrData$t1Confidence,na.rm=T)/sqrt(length(vrData$t1Confidence)),
        sd(vrData$t2Confidence,na.rm=T)/sqrt(length(vrData$t2Confidence)))
xb <- c("Time 1 Confidence","Time 2 Confidence")
yb <- c(mean(vrData$t1Confidence,na.rm=T),mean(vrData$t2Confidence,na.rm=T))
df <- data.frame("TimePoint" = xb, "MeanConfidence"= yb)
inf <- ggplot(df) +
  geom_bar( aes(x=TimePoint, y=MeanConfidence), colour="black", stat="identity", fill="darkgreen", alpha=0.5) +
  geom_errorbar( aes(x=TimePoint, y=MeanConfidence, ymin=MeanConfidence-se, ymax=MeanConfidence+se), colour="orange", alpha=0.6, size=1.1, width = 0.4) + 
  theme_classic()

print(inf +
        ggtitle("Confidence During and After the Scenario") +
        labs(x = "Time Point", y = "Confidence")) 

print(t.test(vrData$t1Confidence,
             vrData$t2Confidence,paired=T))

```

## Actions against Diagnostic Change

```{r, warning=FALSE, message=FALSE}


actCon <- ggplot(data = vrData, aes(x=filteredActions, y=confidenceChange)) +
  geom_point() +
  geom_smooth(method=lm , color="orange", fill="#69b3a2", se=TRUE) +
  theme_classic()

print(actCon + 
        ggtitle("Confidence Change Against Actions Performed")
      + labs(y="Confidence Change", x = "Actions Performed"))

cor.test(vrData$filteredActions,vrData$confidenceChange,method="pearson")



```


## 2 x 2 Plots

```{r, warning=FALSE, message=FALSE}

anovaDf <- data.frame(c(vrData$t1Confidence,vrData$t2Confidence),
                      c(vrData$t1Severity,vrData$t2Severity),
                      c(vrData$t1numOfDiagnoses,vrData$t2numOfDiagnoses),
                      c(rep("1",nrow(vrData)),rep("2",nrow(vrData))),
                      c(rep(vrData$Scenario,2)),
                       c(rep(vrData$scenGroup,2)),
                      c(rep(vrData$ParticipantID,2)))

colnames(anovaDf) <- c("Confidence","Severity","Diagnoses", 
                       "Timepoint","Scenario","ScenarioGroup","ID")

p <- ggplot(anovaDf, aes(x=Timepoint, y=Confidence, fill=Scenario)) + 
    geom_violin() +
    stat_summary(fun.data=data_summary, geom="crossbar", width=0.05, position=position_dodge(0.1)) +
    facet_wrap(~Scenario) +
    theme_classic()

p


p <- ggplot(anovaDf, aes(x=Timepoint, y=Severity, fill=Scenario)) + 
    geom_violin() +
    stat_summary(fun.data=data_summary, geom="crossbar", width=0.05, position=position_dodge(0.1)) +
    facet_wrap(~Scenario) +
    ylim(0,10) +
    theme_classic()

p

p <- ggplot(anovaDf, aes(x=Timepoint, y=Diagnoses, fill=Scenario)) + 
    geom_violin() +
    stat_summary(fun.data=data_summary, geom="crossbar", width=0.05, position=position_dodge(0.1)) +
    facet_wrap(~Scenario) +
    ylim(0,8) +
    theme_classic()

p

completeAnovaDF <- anovaDf[anovaDf$ID %in% vrCompleteData$ParticipantID,]

res.aov2 <- anova_test(
  data = completeAnovaDF, dv = Diagnoses, wid = ID, within = Timepoint, between = Scenario
)

get_anova_table(res.aov2)

#################################################

anovaDf <- data.frame(vrData$filteredActions,
                      vrData$numOfHistoryActions,
                      vrData$t1numOfDiagnoses,
                      vrData$OMSScore,
                      vrData$t2Confidence,
                      vrData$t2InvestigationsComplete,
                        vrData$Scenario,
                       vrData$scenGroup,
                      vrData$scenNum,
                      vrData$ParticipantID)

colnames(anovaDf) <- c("Actions","HistoryTaking","InitialDiagnoses","Score","Confidence", "InvestigationsComplete","Scenario","ScenarioGroup","ScenarioNumber","ID")

# Convert ScenarioGroup to factor with desired order
anovaDf$ScenarioGroup <- factor(anovaDf$ScenarioGroup, levels = c("AS", "DP"))

###########################
# Actions

# Plotting
p <- ggplot(anovaDf, aes(x = Scenario, y = InitialDiagnoses, fill = Scenario)) +
  geom_violin(position = position_dodge(0.8), trim = T) +
  stat_summary(fun.data = data_summary, geom = "crossbar", width = 0.05, position = position_dodge(0.8)) +
  facet_wrap(~ScenarioGroup,scales = "free_x") + 
  theme_classic()

p

completeAnovaDF <- anovaDf[anovaDf$ID %in% vrCompleteData$ParticipantID,]

res.aov2 <- anova_test(
  data = completeAnovaDF, dv = Actions, wid = ID, within = ScenarioNumber, between = ScenarioGroup
)

get_anova_table(res.aov2)

###########################
# Score

# Plotting
p <- ggplot(anovaDf, aes(x = Scenario, y = Score, fill = Scenario)) +
  geom_violin(position = position_dodge(0.8), trim = T) +
  stat_summary(fun.data = data_summary, geom = "crossbar", width = 0.05, position = position_dodge(0.8)) +
  facet_wrap(~ScenarioGroup,scales = "free_x") + 
  theme_classic()

p

res.aov2 <- anova_test(
  data = completeAnovaDF, dv = Score, wid = ID, within = ScenarioNumber, between = ScenarioGroup
)

get_anova_table(res.aov2)


```

## Effect of Completing Investigations

```{r, warning=FALSE, message=FALSE}

anovaDf$InvestigationsComplete <- factor(anovaDf$InvestigationsComplete, levels = c(0, 1))

# Plotting
p <- ggplot(anovaDf[!is.na(anovaDf$InvestigationsComplete),], aes(x = InvestigationsComplete, y = Confidence, fill = ScenarioGroup)) +
  geom_violin(position = position_dodge(0.7), trim = T) +
  stat_summary(fun.data = data_summary, geom = "crossbar", width = 0.05, position = position_dodge(0.7)) +
  theme_classic()

p

res.aov2 <- anova_test(
  data = completeAnovaDF, dv = Score, wid = ID, between = c(InvestigationsComplete, ScenarioGroup)
)

get_anova_table(res.aov2)


```

## Calculate mean distances

```{r, warning=FALSE, message=FALSE}

ids <- unique(vrCompleteData$ParticipantID)
distTable <- data.frame(ids)
for (n in 1:nrow(distTable))
{
  id <- distTable$ids[n]
  # History
  vectors <- str_split(vrCompleteData[vrCompleteData$ParticipantID==id,]$historyActionsVector,"\n")
  vectors <- rbind(as.numeric(vectors[[1]]),as.numeric(vectors[[2]]))
  distTable$infoSeekingDistanceHistory[n] <- vectors  %>% proxy::dist(method = "cosine")
  
  # Physical Exams
  vectors <- str_split(vrCompleteData[vrCompleteData$ParticipantID==id,]$examsActionsVector,"\n")
  vectors <- rbind(as.numeric(vectors[[1]]),as.numeric(vectors[[2]]))
  distTable$infoSeekingDistanceExams[n] <- vectors  %>% proxy::dist(method = "cosine")
  
  # Testing
  vectors <- str_split(vrCompleteData[vrCompleteData$ParticipantID==id,]$testingActionsVector,"\n")
  vectors <- rbind(as.numeric(vectors[[1]]),as.numeric(vectors[[2]]))
  distTable$infoSeekingDistanceTesting[n] <- vectors  %>% proxy::dist(method = "cosine")
  
  vrDataByID <- vrCompleteData[vrCompleteData$ParticipantID==id,]
  distTable$confidenceChange[n] <- mean(vrDataByID$confidenceChange)
  distTable$diagnosticChange[n] <- mean(vrDataByID$diagnosticChange)
  distTable$t1Diagnoses[n] <- mean(vrDataByID$t1numOfDiagnoses)
  distTable$t1Confidence[n] <- mean(vrDataByID$t1Confidence)
  distTable$OMSScore[n] <- mean(vrDataByID$OMSScore,na.rm=T)
  distTable$scenGroup[n] <- vrDataByID$scenGroup[1]
  distTable$numOfActions[n] <- sum(vrDataByID$filteredActions)

}

distTable$meanDistanceAllInfo <- rowMeans(distTable[2:4])
hist(distTable$meanDistanceAllInfo)

distTable$confidenceGroup <- ifelse(distTable$t1Confidence<7,0,1)
distTable$scoreGroup <- ifelse(distTable$OMSScore<63,0,1)

model <- lm(t1Diagnoses ~ infoSeekingDistanceHistory + scenGroup,data=distTable)
summary(model)

distTableScens <- data.frame(scens)
for (scen in scens)
{
  n <- match(scen,scens)
  
  vectors <- str_split(vrData[vrData$Scenario==scen,]$historyActionsVector,"\n")
  numVector <- c()
  for (v in 1:length(vectors))
  {
      numVector <- rbind(numVector,as.numeric(vectors[[v]]))
  }
  distTableScens$infoSeekingDistanceHistory[n] <- mean(numVector  %>% proxy::dist(method = "Hamman")%>% as.matrix)
  
    # Physical Exams
  vectors <- str_split(vrData[vrData$Scenario==scen,]$examsActionsVector,"\n")
  numVector <- c()
  for (v in 1:length(vectors))
  {
      numVector <- rbind(numVector,as.numeric(vectors[[v]]))
  }
  distTableScens$infoSeekingDistanceExams[n] <- mean(vectors  %>% proxy::dist(method = "Hamman") %>% as.matrix)
  
  # Testing
  vectors <- str_split(vrData[vrData$Scenario==scen,]$testingActionsVector,"\n")
  numVector <- c()
  for (v in 1:length(vectors))
  {
      numVector <- rbind(numVector,as.numeric(vectors[[v]]))
  }
  distTableScens$infoSeekingDistanceTesting[n] <- mean(vectors  %>% proxy::dist(method = "Hamman") %>% as.matrix)
}

distTableScens$meanDistanceAllInfo <- rowMeans(distTableScens[2:4])

inf <- ggplot(distTableScens) +
  geom_bar( aes(x=scens, y=infoSeekingDistanceHistory), colour="black", fill=c("#f35e5a", "#b95eff", "#6ba204","#17b3b7"), stat="identity", alpha=0.5) +
  theme_classic() +
  scale_x_discrete(labels = c("Asthma","Seizure","DKA","Pneumonia")) +
  labs(y="Variance in History Taking", x = "Scenario")
  
inf

```

## Low and High Number of Diagnoses

### Confidence

```{r, warning=FALSE, message=FALSE}

hist(vrData$t1numOfDiagnoses)

lowDiags <- vrData[vrData$numOfDiagnosesLabel=="low",]$confidenceChange
highDiags <- vrData[vrData$numOfDiagnosesLabel=="high",]$confidenceChange

se <- c(sd(lowDiags,na.rm=T)/sqrt(length(lowDiags)),
        sd(lowDiags,na.rm=T)/sqrt(length(highDiags)))
xb <- c("Low Num. of Diagnoses (<4)","High Num. of Diagnoses")
yb <- c(mean(lowDiags,na.rm=T),mean(highDiags,na.rm=T))
df <- data.frame("DiagnosticBreadth" = xb, "MeanConfidence"= yb)
inf <- ggplot(df) +
  geom_bar( aes(x=DiagnosticBreadth, y=MeanConfidence), colour="black", stat="identity", fill=confidenceColour, alpha=0.5) +
  geom_errorbar( aes(x=DiagnosticBreadth, y=MeanConfidence, ymin=MeanConfidence-se, ymax=MeanConfidence+se), colour="orange", alpha=0.6, size=1.1, width = 0.4) + 
  scale_x_discrete(limits = xb) +
  theme_classic()

print(inf +
        ggtitle("Confidence by Diagnoses") +
        labs(x = "Num of Diagnoses", y = "Change in Confidence (T2-T1)")) 

print(t.test(lowDiags,highDiags))


```

### Information Seeking

```{r, warning=FALSE, message=FALSE}

hist(vrData$filteredActions)

lowDiags <- vrData[vrData$numOfDiagnosesLabel=="low",]$numOfHistoryActionsBeforePause
highDiags <- vrData[vrData$numOfDiagnosesLabel=="high",]$numOfHistoryActionsBeforePause

se <- c(sd(lowDiags,na.rm=T)/sqrt(length(lowDiags)),
        sd(lowDiags,na.rm=T)/sqrt(length(highDiags)))
xb <- c("Low Num. of Diagnoses (<4)","High Num. of Diagnoses")
yb <- c(mean(lowDiags,na.rm=T),mean(highDiags,na.rm=T))
df <- data.frame("DiagnosticBreadth" = xb, "InformationSeeking"= yb)
inf <- ggplot(df) +
  geom_bar( aes(x=DiagnosticBreadth, y=InformationSeeking), colour="black", stat="identity", fill=infoSeekingColour, alpha=0.5) +
  geom_errorbar( aes(x=DiagnosticBreadth, y=InformationSeeking, ymin=InformationSeeking-se, ymax=InformationSeeking+se), colour="orange", alpha=0.6, size=1.1, width = 0.4) + 
  theme_classic()

print(inf +
        ggtitle("Information Seeking by Diagnoses") +
        labs(x = "Num of Diagnoses", y = "Information Seeking")) 

print(t.test(lowDiags,highDiags))

numDiagCon <- vrDataNoNAs %>%
  group_by(t1numOfDiagnoses) %>%
  dplyr::mutate(N = n()) %>%
  dplyr::summarise(m_N = mean(N),
                  confidenceChange = mean(confidenceChange),
                  numOfHistoryActions = mean(numOfHistoryActions),
                  infoSeeking = mean(filteredActions))

inf <- ggplot(numDiagCon) +
  geom_bar( aes(x=t1numOfDiagnoses, y=confidenceChange), colour="black", stat="identity", fill=confidenceColour, alpha=0.5)+ 
  theme_classic() +
  scale_x_continuous(breaks = c(1,2,3,4,5,6,7)) +
  labs(x = "Num of Diagnoses", y = "Change in Confidence (T2 - T1)")

inf <- ggplot(numDiagCon) +
  geom_bar( aes(x=t1numOfDiagnoses, y=infoSeeking), colour="black", stat="identity", fill=infoSeekingColour, alpha=0.5)+ 
  theme_classic() +
  scale_x_continuous(breaks = c(1,2,3,4,5,6,7)) +
  labs(x = "Num of Diagnoses", y = "Overall Information Seeking")


```

## Linear Modelling

```{r, warning=FALSE, message=FALSE}

# t1Confidence, infoVal, numOfActions, scenario, numOfDiagnoses
# diagnosticChange, percentageHistory

model <- lmerTest::lmer(confidenceChange ~ t1numOfDiagnoses + infoVal + filteredActions + Scenario + (1 | ParticipantID), data=vrDataNoNAs)
summary(model)

model <- lm(t1DiagnosisScore ~ t1numOfDiagnoses + filteredActions, data=vrDataNoNAs)

library(interactions)
intplot <- interact_plot(model, pred = t1numOfDiagnosesChange, modx = filteredActions) +
  labs(y="Change in Confidence", x = "Change in Diagnoses", colour = "Information Seeking") +
  theme(axis.text=element_text(size=16),
        axis.title=element_text(size=16),
        legend.title=element_text(size=16),
        legend.text=element_text(size=16))
print(intplot)

histCon <- ggplot(data = vrData, aes(x=numOfHistoryActionsBeforePause, y=t1numOfDiagnoses)) +
  geom_point() +
  geom_smooth(method=lm , color=confidenceColour, fill="green", se=TRUE) +
  theme_classic()

print(histCon + 
        ggtitle("Amount of History Taking Against Number of Initial Diagnoses") +
      labs(y="Number of Diagnoses (T1)", x = "Amount of History Taking"))

cor <- cor.test(vrData$percentageTesting,vrData$confidenceChange)


```

## Completed Participants Table

```{r, warning=FALSE, message=FALSE}

compTable <- vrCompleteData %>%
  group_by(ParticipantID) %>%
  summarise(infoVal = mean(infoVal),
            diagChange = mean(diagnosticChange),
            filteredActions = mean(filteredActions),
            initialConfidence = mean(t1Confidence),
            initialDiagnoses = mean(t1numOfDiagnoses),
            confidenceChange = mean(confidenceChange)) %>%
  ungroup()

colnames(distTable) <- "ParticipantID"
compTable <- merge(compTable, distTable, by = "ParticipantID")
colnames(compTable) <- c("ID", "InformationValue","DiagnosticChange","InformationAmount","InitialConfidence","InitialDiagnoses","ConfidenceChange","HistoryVariance","ExamVariance","TestingVariance","InformationVariance")

print(compTable)

#########

```


```{r}

#######################################
# Use of regular PCA


infoSeekingMatrixVRPCA <- infoSeekingMatrixVR[,1:82]
infoSeekingMatrixVRPCA <- infoSeekingMatrixVRPCA[,-which(names(infoSeekingMatrixVRPCA) %in% c("past medical history","measure oxygen saturations & heart rate","measure blood pressure"))] 
# Remove columns that are sought on most scenarios

# Perform PCA on binary data
pca_result <- PCA(infoSeekingMatrixVRPCA, graph = FALSE)

# Scree plot shows elbow around 5
qplot(c(1:79), pca_result$eig[,2]) + 
  geom_line() + 
  xlab("Principal Component") + 
  ylab("Variance Explained") +
  ggtitle("Scree Plot") +
  theme_classic()

#########

pca_result <- principal(infoSeekingMatrixVRPCA, nfactors = 4, rotate = "promax")
pcs <- pca_result$scores
weights <- pca_result$loadings

topPCS <- weights


rownames(topPCS) <- c(1:79)

# Sort the columns alphabetically
colnames(topPCS) <- c("RC1", "RC2", "RC3", "RC4")
topPCS <- topPCS[, order(colnames(topPCS))]


# Determine the maximum absolute value in the loadings matrix
max_abs <- max(abs(c(min(topPCS), max(topPCS))))
# Normalize the data to the range [-1, 1]
normalized_topPCS <- topPCS / max_abs
# Define a custom color palette with clear differentiation between negative, zero, and positive values
n_colors <- 20
color_palette <- colorRampPalette(c("blue", "white", "red"))(n_colors)

apcluster::heatmap(normalized_topPCS,
                   main = "Variable Weights (Normalised) Clustered by PC",
                   xlab = "PCs", ylab = "Test",
                   col = color_palette, scale = "none", breaks = seq(-1, 1, length.out = n_colors + 1), Colv = NA)

# Define colors for legend
legend_colors <- c("blue", "white", "red")

# Add color key
legend("topleft", legend = c("Negative", "Zero", "Positive"),
       fill = legend_colors, title = "Color Key", cex = 0.8)

pcs <- pcs[, order(colnames(pcs))]
pcDF <- data.frame(pcs[,1],pcs[,2],pcs[,3],pcs[,4])
colnames(pcDF) <- c("PC1","PC2","PC3","PC4")
pcDF$pid <- vrData$ParticipantID
pcDF$condition <- vrData$Scenario
pcDF$diagChange <- vrData$diagnosticChange
pcDF$confidenceChange <- vrData$confidenceChange
pcDF$OMSScore <- vrData$OMSScore
pcDF$diagScore <- vrData$t1DiagnosisScore

mixedPCModel = lm(diagScore ~ PC1 + PC2 + PC3 + PC4 + condition, data = pcDF)
summary(mixedPCModel)

```

```{r}

classifierDataVR <- infoSeekingMatrixVR[,c(1:35,84,85)]
classifierDataVR$ScoreGroup <- ifelse(classifierDataVR$OMSScore>median(classifierDataVR$OMSScore,na.rm=T),1,0)
classifierDataVR$ScoreGroup <- as.factor(classifierDataVR$ScoreGroup)

classifierDataVR <- classifierDataVR[!is.na(classifierDataVR$t1Confidence),]

classifierDataVR$ConfidenceGroup <- ifelse(classifierDataVR$t1Confidence>6,1,0)
classifierDataVR$ConfidenceGroup <- as.factor(classifierDataVR$ConfidenceGroup)
colnames(classifierDataVR)[1:35] <- c("T1", "T2",  "T3",  "T4",  "T5",  "T6",  "T7",  
                                      "T8",  "T9", "T10", "T11", "T12", "T13", "T14", 
                                      "T15", "T16", "T17", "T18", "T19", "T20", "T21", "T22", 
                                      "T23", "T24", "T25", "T26", "T27", "T28", "T29",
                                    "T30", "T31", "T32", "T33", "T34", "T35")


thresh<-seq(0,1,0.001)
#specify the cross-validation method
ctrl <- trainControl(method = "LOOCV", number = 100, savePredictions = TRUE)

# Shuffle rows in case there are order biases
classifierDataVR <- classifierDataVR[sample(1:nrow(classifierDataVR)),]

#T33, T34 AND T35 ONLY SOUGHT ON ONE TRIAL, T30 LOW TOO
  modelglm<-train(ConfidenceGroup ~ T1 + T2 + T3 + T4 + T5 + T6 + T7 + T8 + T9 + T10 +
                    T11 + T12 + T13 + T14 + T15 + T16 + T17 +  T18 + T19 + T20 +
                    T21 + T22 + T23 + T24 + T25 + T26 + T27 + T28 + T29 + T30 +
                    T31 + T32, 
                  method = "glm", family = binomial(link=probit), data = classifierDataVR, trControl = ctrl)
  prediglm<-predict(modelglm,type = "prob")[2]
  

# Plot all test results on one ROC curve
rocPlot <- roc.plot(x=classifierDataVR$ConfidenceGroup=="1",pred=cbind(prediglm),legend = T,
                    leg.text = c("GLM"),thresholds = thresh)$roc.vol


```


```{r}
########################

histCon <- ggplot(data = vrData[vrData$totalHelpStart<9999,], aes(x=t1Confidence, y=totalHelpStart)) +
  geom_point() +
  geom_smooth(method=lm , color=infoSeekingColour, fill="red", se=TRUE) +
  theme_minimal()

print(histCon + 
      labs(y="Time to Help", x = "Initial Confidence") +
        scale_x_continuous(breaks = c(1,2,3,4,5,6,7,8,9,10)) +
        theme(axis.text=element_text(size=16),
             axis.title=element_text(size=16),
             plot.title=element_text(size=14,face="bold")
      ))

cor <- cor.test(vrData[vrData$totalHelpStart<9999,]$t1Confidence,vrData[vrData$totalHelpStart<9999,]$totalHelpStart)


########################

histCon <- ggplot(data = vrData[vrData$totalHelpStart<9999,], aes(x=numOfHistoryActionsBeforePause, y=totalHelpStart)) +
  geom_point() +
  geom_smooth(method=lm , color=confidenceColour, fill="green", se=TRUE) +
  theme_minimal()

print(histCon + 
      labs(y="Time to Help", x = "History Taking Amount (Before Pause)") +
        scale_x_continuous(breaks = c(1,2,3,4,5,6,7,8,9,10)) +
        theme(axis.text=element_text(size=16),
             axis.title=element_text(size=16),
             plot.title=element_text(size=14,face="bold")
      ))

cor <- cor.test(vrData[vrData$totalHelpStart<9999,]$numOfHistoryActionsBeforePause,vrData[vrData$totalHelpStart<9999,]$totalHelpStart)

```
